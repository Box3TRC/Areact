declare type IEffectFunc = () => void | (() => void) | Promise<void>;
declare type IStateSetValue<T> = (value: T | ((arg: T) => T)) => void;
interface IHookEffectHolder {
    deps?: any[];
    effectFunc?: IEffectFunc;
    cleanupFunc?: () => void;
}
export interface IHookRefObject<T> {
    current: T | undefined;
}
export interface IHookInstance {
    holders: any[];
    index: number;
    pendingEffectHolders: IHookEffectHolder[];
}
export declare function createHookInstance(): IHookInstance;
export declare function useState<T>(initialValue: T): [T, IStateSetValue<T>];
export declare function useLocal<T extends object>(arg: T | (() => T)): T;
export declare function useMemo<T>(func: () => T, deps: any[]): T;
export declare function useCallback<T extends (...args: any) => any>(func: T, deps: any[]): T;
export declare function useEffect(effectFunc: IEffectFunc, deps: any[] | undefined): void;
export declare function useInlineEffect(effectFunc: IEffectFunc, deps: any[] | undefined): void;
export declare function useRef<T>(): IHookRefObject<T>;
export declare function startHooks(target: IHookInstance): void;
export declare function endHooks(): void;
export declare function flushHookEffects(target: IHookInstance, all?: boolean): void;
export {};
