import { aluminaGlobal } from './aluminaGlobal';
export function createHookInstance() {
    return {
        holders: [],
        index: 0,
        pendingEffectHolders: [],
    };
}
function hasDepsChanged(oldDeps, newDeps) {
    if (!oldDeps || !newDeps) {
        return true;
    }
    for (let i = 0; i < oldDeps.length; i++) {
        if (oldDeps[i] !== newDeps[i]) {
            return true;
        }
    }
    return false;
}
function getHookHolder() {
    const gHookInstance = aluminaGlobal.gHookInstance;
    if (!gHookInstance) {
        throw new Error('hook functions called outside render context');
    }
    const hk = gHookInstance;
    let holder = hk.holders[hk.index];
    let first = false;
    if (!holder) {
        holder = hk.holders[hk.index] = {};
        first = true;
    }
    hk.index++;
    return { holder, first };
}
export function useState(initialValue) {
    const { holder, first } = getHookHolder();
    if (first) {
        holder.value = initialValue;
        holder.setValue = (arg) => {
            if (typeof arg === 'function') {
                holder.value = arg(holder.value);
            }
            else {
                holder.value = arg;
            }
        };
    }
    const { value, setValue } = holder;
    return [value, setValue];
}
export function useLocal(arg) {
    const initialValue = 'call' in arg ? arg() : arg;
    const [value] = useState(initialValue);
    return value;
}
export function useMemo(func, deps) {
    const { holder } = getHookHolder();
    const changed = hasDepsChanged(holder.deps, deps);
    if (changed) {
        holder.value = func();
        holder.deps = deps;
    }
    return holder.value;
}
export function useCallback(func, deps) {
    const { holder } = getHookHolder();
    const changed = hasDepsChanged(holder.deps, deps);
    if (changed) {
        holder.value = func;
        holder.deps = deps;
    }
    return holder.value;
}
export function useEffect(effectFunc, deps) {
    const { holder } = getHookHolder();
    const changed = hasDepsChanged(holder.deps, deps);
    if (changed) {
        holder.effectFunc = effectFunc;
        holder.deps = deps;
        const gHookInstance = aluminaGlobal.gHookInstance;
        gHookInstance.pendingEffectHolders.push(holder);
    }
}
export function useInlineEffect(effectFunc, deps) {
    const { holder } = getHookHolder();
    const changed = hasDepsChanged(holder.deps, deps);
    if (changed) {
        const result = effectFunc();
        if (result && typeof result === 'function') {
            holder.cleanupFunc = result;
        }
        holder.deps = deps;
    }
}
export function useRef() {
    const { holder, first } = getHookHolder();
    if (first) {
        holder.refObject = { current: undefined };
    }
    return holder.refObject;
}
export function startHooks(target) {
    target.index = 0;
    aluminaGlobal.gHookInstance = target;
}
export function endHooks() {
    aluminaGlobal.gHookInstance = undefined;
}
export function flushHookEffects(target, all = false) {
    const holders = (all ? target.holders : target.pendingEffectHolders);
    holders.forEach((holder) => {
        if (holder.cleanupFunc) {
            holder.cleanupFunc();
            holder.cleanupFunc = undefined;
        }
        if (holder.effectFunc) {
            const result = holder.effectFunc();
            if (result && typeof result === 'function') {
                holder.cleanupFunc = result;
            }
            aluminaGlobal.asyncRerenderFlag = true;
            holder.effectFunc = undefined;
        }
    });
    target.pendingEffectHolders = [];
}
//# sourceMappingURL=hookImpl.js.map