'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const latentSet = function (target, name, value) {
    if (!target.hasOwnProperty(name)) {
        Object.defineProperty(target, name, {
            value,
            enumerable: false,
            configurable: false
        });
    }
};
const warning = function (condition, message) {
    if (!condition) {
        throw new Error(message);
    }
};
const isArray = Array.isArray;
const isNull = function (object) {
    return object === null;
};
const isNil = function (object) {
    return object === null || object === undefined;
};
const isPlainObject = function (object) {
    return Object.prototype.toString.call(object) === '[object Object]';
};
const isString = function (object) {
    return typeof object === 'string';
};
const isNumber = function (object) {
    return typeof object === 'number';
};
const isFunction = function (object) {
    return typeof object === 'function';
};
const isEqualObject = function (object, other) {
    if (isPlainObject(object) && isPlainObject(other)) {
        const entries1 = Object.entries(object);
        const entries2 = Object.entries(other);
        if (entries1.length !== entries2.length) {
            return false;
        }
        for (let i = 0; i < entries1.length; i++) {
            const [k1, v1] = entries1[i];
            const [k2, v2] = entries2[i];
            if (k1 !== k2 || v1 !== v2) {
                return false;
            }
        }
        return true;
    }
    return false;
};
const isEqualArray = function (array, other) {
    if (isArray(array) && isArray(other) && array.length === other.length) {
        for (let i = 0; i < array.length; i++) {
            if (!Object.is(array[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    return false;
};
/**
 * depth first search algorithm
 * @param node tree object
 * @param key children key name
 * @param handler hanlder function that will be run on every node
 * @param index index of current node
 * @param parentNode parent node
 */
const dfsWalk = function (node, key, handler, index = 0, parentNode = null) {
    if (isNull(node)) {
        return;
    }
    if (!handler.call(null, node, index, parentNode)) {
        return;
    }
    const children = node[key];
    if (children && isArray(children)) {
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            dfsWalk(child, key, handler, i, node);
        }
    }
};
/**
 * calculate longest increasing subsequence (only for positive numbers)
 * @param arr array of number
 */
const calcLis = function (arr) {
    const M = [-1];
    const P = [];
    const S = [];
    let i;
    let left;
    let right;
    let mid;
    let len;
    for (i = 0, len = arr.length; i < len; i++) {
        // skip negative numbers
        if (arr[i] < 0) {
            continue;
        }
        left = 1;
        right = M.length;
        while (left < right) {
            mid = Math.floor((left + right) / 2);
            if (arr[M[mid]] < arr[i]) {
                left = mid + 1;
            }
            else {
                right = mid;
            }
        }
        M[left] = i;
        P[i] = M[left - 1];
    }
    len = M.length - 1;
    i = M[len];
    while (i !== -1) {
        S[len-- - 1] = arr[i];
        i = P[i];
    }
    return S;
};

const PROP_CLASS_PRESERVED = 'class';
const PROP_CLASS = 'className';
const PROP_STYLE = 'style';
const PROP_REF = 'ref';
const PROP_KEY = 'key';
const PROP_VALUE = 'value';
const PROP_CHILDREN = 'children';
const PROP_DANGEROUS_HTML = 'dangerouslySetInnerHTML';
const PROP_EVENT_PREFIX = 'on';
const NODE_TYPE_EMPTY = 'NODE_TYPE_EMPTY';
const NODE_TYPE_TEXT = 'NODE_TYPE_TEXT';
const NODE_TYPE_LIST = 'NODE_TYPE_LIST';
const NODE_TYPE_FRAGMENT = 'NODE_TYPE_FRAGMENT';
const ACTION_REPLACE = Symbol.for('ACTION_REPLACE');
const ACTION_REORDER = Symbol.for('ACTION_REORDER');
const ACTION_UPDATE_PROPS = Symbol.for('ACTION_UPDATE_PROPS');

const makeReplaceAction = function (item) {
    return {
        type: ACTION_REPLACE,
        payload: item
    };
};
const makeUpdatePropsAction = function (attributes, events) {
    return {
        type: ACTION_UPDATE_PROPS,
        payload: {
            attributes,
            events
        }
    };
};
const createRef = () => {
    return {
        current: null
    };
};
const loadStyle = (element, currStyle, prevStyle) => {
    if (isPlainObject(prevStyle)) {
        for (const styleKey in prevStyle) {
            if (prevStyle.hasOwnProperty(styleKey)) {
                element.style[styleKey] = '';
            }
        }
    }
    for (const styleKey in currStyle) {
        if (currStyle.hasOwnProperty(styleKey)) {
            const styleVal = currStyle[styleKey];
            element.style[styleKey] = styleVal;
        }
    }
};
const loadDangerousInnerHTML = (element, value) => {
    if (isString(value)) {
        element.innerHTML = value;
    }
    else if (isFunction(value)) {
        element.innerHTML = value.call(null);
    }
    else {
        element.innerHTML = Object.prototype.toString.call(value);
    }
};

const StaticContext = {
    // store currently rendering component instance in global environment
    currentInstance: null,
    setCurrentInstance(comp) {
        StaticContext.currentInstance = comp;
    },
    clearCurrentInstance() {
        StaticContext.currentInstance = null;
    },
    useState(state) {
        return StaticContext.currentInstance.useStateHook(state);
    },
    useEffect(effect, relativeState) {
        warning(isArray(relativeState) || isNil(relativeState), 'relative state should be an array or an undefined value');
        return StaticContext.currentInstance.useEffect(effect, relativeState);
    },
    useContext(contextComp) {
        const instance = StaticContext.currentInstance;
        const ancestorNode = instance.virtualNode.findAncestor((node) => {
            return (node.el && node.el.render === contextComp.Provider);
        });
        const contextCompMap = instance.getContextCompMap();
        if (contextCompMap.has(contextComp)) {
            return contextCompMap.get(contextComp).getValue();
        }
        else {
            instance.ancestorProvider = ancestorNode
                ? ancestorNode.el
                : null;
            instance.unsubscriber = ancestorNode
                ? instance.ancestorProvider.subscribe(instance)
                : null;
            instance.afterUnmount = () => {
                if (instance.unsubscriber) {
                    instance.unsubscriber();
                }
            };
            if (!instance.ancestorProvider) {
                return contextComp.initialValue;
            }
            else {
                contextCompMap.set(contextComp, instance.ancestorProvider);
                return instance.ancestorProvider.getValue();
            }
        }
    }
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/**
 * Diffable abstract class, any class extends this class shall implement the patch procedure
 * method(run), the child class will later be injected into VirtualNode for reconciliation.
 * A static factory method is provided to get patchable procedure instance, target node and
 * patch data shall be passed when running.
 * This design is for code decoupling.
 */
class Patchable {
    static getInstance(Clazz, target, patchData) {
        return new Clazz(target, patchData);
    }
    constructor(target, patchData) {
        this.target = target;
        this.patchData = patchData;
    }
}

class PatchReplace extends Patchable {
    constructor(target, patchData) {
        super(target, patchData);
    }
    run() {
        const target = this.target;
        const { payload } = this.patchData;
        target.unmountFromDom();
        if (target.isComponentNode()) {
            target.el.unmount();
        }
        else if (!target.isEmptyNode() && !target.isTextNode()) {
            const comps = target.getChildrenCompNodes();
            for (const comp of comps) {
                comp.unmount();
            }
        }
        this.loadAttributes(payload);
        target.clearPatchable();
        target.reflectToDom();
        if (!target.isComponentNode() && isArray(target.children)) {
            for (const child of target.children) {
                child.reflectDescendantsToDom();
            }
        }
    }
    loadAttributes(that) {
        const target = this.target;
        target.tagType = that.tagType;
        target.attributes = that.attributes || {};
        target.children = that.children || [];
        target.events = that.events || {};
        if (isArray(target.children)) {
            for (const child of target.children) {
                child.parentNode = target;
            }
        }
        if (that.reserved) {
            target.reserved = that.reserved;
        }
        else {
            delete target.reserved;
        }
        if (!isNil(that.value)) {
            target.value = that.value;
        }
        else {
            delete target.value;
        }
        delete target.el;
    }
}

class PatchUpdateProps extends Patchable {
    constructor(target, patchData) {
        super(target, patchData);
    }
    run() {
        const target = this.target;
        const isDomNode = target.isTaggedDomNode();
        const isCompNode = target.isComponentNode();
        if (isDomNode || isCompNode) {
            const prevProps = Object.assign({}, target.attributes);
            const { attributes, events } = this
                .patchData.payload;
            for (const key in attributes) {
                if (attributes.hasOwnProperty(key)) {
                    const value = attributes[key];
                    target.attributes[key] = value;
                    if (isDomNode) {
                        if (key === PROP_STYLE) {
                            loadStyle(target.el, value, prevProps[PROP_STYLE]);
                        }
                        else if (key === PROP_VALUE) {
                            target.el.value = value;
                        }
                        else if (key === PROP_DANGEROUS_HTML) {
                            // children nodes will be disactive due to the dangerous inner html
                            target.children = [];
                            loadDangerousInnerHTML(target.el, value);
                        }
                        else {
                            target.el.setAttribute(key, value);
                        }
                    }
                }
            }
            if (isCompNode) {
                target.el.forceRenderDom();
            }
            else if (isDomNode) {
                for (const key in events) {
                    if (events.hasOwnProperty(key)) {
                        const eventHandler = events[key];
                        target.el[key.toLowerCase()] = eventHandler;
                    }
                }
            }
        }
        target.clearPatchable();
    }
}

class PatchReorderLisBasedDiff extends Patchable {
    constructor(target, patchData) {
        super(target, patchData);
    }
    run() {
        const listNode = this.target;
        const { removes, moves, insertions, tailsInss } = this.patchData
            .payload;
        let startNode = listNode[PROP_CHILDREN][0];
        let target;
        let prevPivot = null;
        let pivot;
        let i, len;
        // a list for move target nodes, a map for prev nodes of which and a list for destination nodes
        // prev nodes could be updated while processing deleting and moving
        const toBeMovedNodeList = [];
        const destinationNodeList = [];
        const nodePrevNodeMap = new WeakMap();
        for (i = 0, len = moves.length; i < len; i++) {
            const { item, to } = moves[i];
            target = (item === undefined
                ? startNode
                : item.nextSibling);
            toBeMovedNodeList.push(target);
            destinationNodeList.push(to);
            nodePrevNodeMap.set(target, item);
        }
        // handle remove actions
        while (removes.length) {
            const prevNode = removes.pop();
            let toBeRemoved;
            if (isNil(prevNode)) {
                toBeRemoved = listNode[PROP_CHILDREN][0];
                startNode = startNode.nextSibling;
                if (nodePrevNodeMap.has(startNode)) {
                    nodePrevNodeMap.set(startNode, null);
                }
            }
            else {
                toBeRemoved = prevNode.nextSibling;
                prevNode.nextSibling = prevNode.nextSibling.nextSibling;
                if (nodePrevNodeMap.has(prevNode.nextSibling)) {
                    nodePrevNodeMap.set(prevNode.nextSibling, prevNode);
                }
            }
            toBeRemoved.unmountFromDom();
        }
        // handle move actions
        for (i = 0, len = destinationNodeList.length; i < len; i++) {
            const destination = destinationNodeList[i];
            const toBeMovedNode = toBeMovedNodeList[i];
            const prevNode = nodePrevNodeMap.get(toBeMovedNode);
            if (isNil(prevNode)) {
                startNode = toBeMovedNode.nextSibling;
            }
            else {
                prevNode.nextSibling = prevNode.nextSibling.nextSibling;
                if (nodePrevNodeMap.has(prevNode.nextSibling)) {
                    nodePrevNodeMap.set(prevNode.nextSibling, prevNode);
                }
            }
            if (isNil(destination)) {
                toBeMovedNode.nextSibling = startNode;
                startNode = toBeMovedNode;
            }
            else {
                toBeMovedNode.nextSibling = destination.nextSibling;
                if (nodePrevNodeMap.has(destination.nextSibling)) {
                    nodePrevNodeMap.set(destination.nextSibling, toBeMovedNode);
                }
                destination.nextSibling = toBeMovedNode;
            }
            // mount to dom
            if (toBeMovedNode.isListNode() || toBeMovedNode.isComponentNode()) {
                const domChildrenVNodes = toBeMovedNode.getDomChildrenVNodes();
                for (const vNode of domChildrenVNodes) {
                    vNode.mountToDom();
                }
            }
            else {
                toBeMovedNode.mountToDom();
            }
        }
        // handle insertions between normal nodes
        pivot = startNode;
        while (pivot) {
            const newNodes = insertions.get(pivot);
            if (newNodes && newNodes.length) {
                newNodes[0].nextSibling = pivot;
                newNodes[0].parentNode = listNode;
                newNodes[0].reflectDescendantsToDom();
                for (i = 1, len = newNodes.length; i < len; i++) {
                    newNodes[i].nextSibling = newNodes[i - 1];
                    newNodes[i].parentNode = listNode;
                    newNodes[i].reflectDescendantsToDom();
                }
                if (isNil(prevPivot)) {
                    startNode = newNodes[newNodes.length - 1];
                }
                else {
                    prevPivot.nextSibling = newNodes[i - 1];
                }
            }
            prevPivot = pivot;
            pivot = pivot.nextSibling;
        }
        // handle tail insertions
        // use prevPivot as the start node
        for (i = tailsInss.length - 1, len = 0; i > len; i--) {
            tailsInss[i].nextSibling = tailsInss[i - 1];
            tailsInss[i].parentNode = listNode;
            tailsInss[i].reflectDescendantsToDom();
        }
        if (tailsInss.length) {
            tailsInss[0].parentNode = listNode;
            tailsInss[0].reflectDescendantsToDom();
            if (isNil(prevPivot)) {
                startNode = tailsInss[tailsInss.length - 1];
            }
            else {
                prevPivot.nextSibling = tailsInss[tailsInss.length - 1];
            }
        }
        const newChildren = [];
        pivot = startNode;
        while (pivot) {
            newChildren.push(pivot);
            pivot = pivot.nextSibling;
        }
        listNode.children = newChildren;
        listNode.clearPatchable();
    }
}

/**
 * Diffable abstract class, any class extends this class shall implement keyed list algorithm,
 * the run method.
 * The child class will later be injected into VirtualNode for diff calculation.
 * A static factory method is provided to get pooled diffable algorithm instance.
 * This design is for code decoupling.
 */
class Diffable {
    constructor() { }
    static getInstance(DiffableImpl) {
        if (Diffable.ClassInstMap.has(DiffableImpl)) {
            return Diffable.ClassInstMap.get(DiffableImpl);
        }
        let inst = new DiffableImpl();
        Diffable.ClassInstMap.set(DiffableImpl, inst);
        return inst;
    }
    diffFreeList(oldList, newList) {
        warning(oldList.length === newList.length, 'calculating invalid free list difference, length unequaled');
        for (let i = 0; i < oldList.length; i++) {
            this.run(oldList[i], newList[i]);
        }
    }
    run(oldVDom, newVDom, key = 'key') {
        if (oldVDom.isEmptyNode() && newVDom.isEmptyNode()) {
            return;
        }
        // difference has already been calculated
        if (oldVDom.hasPatchable()) {
            return;
        }
        if (!oldVDom.sameTypeWith(newVDom) ||
            oldVDom.isEmptyNode() ||
            newVDom.isEmptyNode()) {
            oldVDom.setPatchable(Patchable.getInstance(PatchReplace, oldVDom, makeReplaceAction(newVDom)));
        }
        else if (oldVDom.isTextNode() && newVDom.isTextNode()) {
            if (oldVDom.value !== newVDom.value) {
                oldVDom.setPatchable(Patchable.getInstance(PatchReplace, oldVDom, makeReplaceAction(newVDom)));
            }
        }
        else {
            const { tagType: oldTagType, attributes: oldAttributes, children: oldChildren, events: oldEvents } = oldVDom;
            const { tagType: newTagType, attributes: newAttributes, children: newChildren, events: newEvents } = newVDom;
            if (oldTagType !== newTagType) {
                oldVDom.setPatchable(Patchable.getInstance(PatchReplace, oldVDom, makeReplaceAction(newVDom)));
                return;
            }
            else if (!isEqualObject(oldAttributes, newAttributes) ||
                !isEqualObject(oldEvents, newEvents) ||
                (isNil(oldAttributes) &&
                    isNil(newAttributes) &&
                    isNil(oldEvents) &&
                    isNil(newEvents))) {
                oldVDom.setPatchable(Patchable.getInstance(PatchUpdateProps, oldVDom, makeUpdatePropsAction(newAttributes, newEvents)));
            }
            if (oldVDom.isListNode() && newVDom.isListNode()) {
                oldVDom.setPatchable(Patchable.getInstance(PatchReorderLisBasedDiff, oldVDom, this.diffKeyedList(oldChildren, newChildren, key)));
            }
            else if (!oldVDom.isComponentNode() && !newVDom.isComponentNode()) {
                this.diffFreeList(oldChildren, newChildren);
            }
            else if (oldVDom.isComponentNode() && newVDom.isComponentNode()) {
                const comp = oldVDom.el;
                const prevProps = Object.assign({}, oldVDom.attributes);
                oldVDom.attributes = newVDom.attributes;
                oldVDom.events = newVDom.events;
                if (!comp.isWaitingContextProviderUpdate()) {
                    comp.renderDom(prevProps);
                }
            }
        }
    }
}
Diffable.ClassInstMap = new WeakMap();
const DiffAlgorithmFactory = function (Algo) {
    return (target, prop) => {
        target[prop] = Diffable.getInstance(Algo);
    };
};

/**
 * Longest Increasing Subsequence based keyed list diff algorithm, LIS helped to make
 * unneccesary node moves at maximum degree.
 */
class DiffAlgorithmLisBased extends Diffable {
    constructor() {
        super();
    }
    /**
     * trim same elements for two arrays, return deviation counts of beginning and ending
     * @param list1 array of object
     * @param list2 array of object
     * @param key key name for identification
     */
    trimTwoLists(list1, list2, key) {
        let sd = 0;
        let ed = 0;
        let idx1 = 0, idx2 = 0;
        const { length: len1 } = list1;
        const { length: len2 } = list2;
        while (sd < len1 && sd < len2 && list1[idx1][key] === list2[idx1][key]) {
            this.run(list1[idx1], list2[idx2]);
            sd++;
            idx1 = sd;
            idx2 = sd;
        }
        idx1 = len1 - ed - 1;
        idx2 = len2 - ed - 1;
        while (sd + ed < len1 &&
            sd + ed < len2 &&
            list1[idx1][key] === list2[idx2][key]) {
            this.run(list1[idx1], list2[idx2]);
            ed++;
            idx1 = len1 - ed - 1;
            idx2 = len2 - ed - 1;
        }
        return [sd, ed];
    }
    /**
     * diff two arrays of number, Takes O(nlogn) time in expectation
     * @param list1 array of characters
     * @param list2 array of characters
     */
    diffKeyedList(list1, list2, key = PROP_KEY) {
        const { length: len1 } = list1;
        const { length: len2 } = list2;
        const [sd, ed] = this.trimTwoLists(list1, list2, key);
        const pTailsIn = []; // tail insertions
        const pMovs = []; // move patches
        const pRmvs = []; // remove patches
        const pInss = new Map();
        const IM = new Map(); // index map of length1
        const IT = new Array(len2 - sd - ed).fill(-1); // index table of length2
        let LIS; // longest increasing subsequence of index table
        let shouldMoved = false; // no need to move if LIS.length == IT.length(positive numbers only)
        let i, j, k, end, last, patches;
        for (i = sd, end = len2 - ed; i < end; i++) {
            IM.set(list2[i].key, i);
        }
        last = -1;
        for (i = sd, end = len1 - ed; i < end; i++) {
            j = IM.get(list1[i].key);
            if (j !== undefined) {
                this.run(list1[i], list2[j]);
                IT[j - sd] = i;
                if (j < last) {
                    shouldMoved = true;
                }
                else {
                    last = j;
                }
            }
            else {
                pRmvs.push(list1[i - 1]);
            }
        }
        LIS = calcLis(IT); // calculate LIS of old list index table
        last = IT.length;
        for (i = len2 - ed - 1, j = LIS.length - 1, end = sd - 1; i > end; i--) {
            k = i - sd;
            if (IT[k] === -1) {
                if (last !== IT.length) {
                    if (pInss.has(list1[IT[last]])) {
                        patches = pInss.get(list1[IT[last]]);
                    }
                    else {
                        patches = [];
                        pInss.set(list1[IT[last]], patches);
                    }
                    patches.push(list2[i]);
                }
                else if (ed !== 0) {
                    // put tail insertions into header node of trimed tail list
                    if (pInss.has(list1[len1 - ed])) {
                        patches = pInss.get(list1[len1 - ed]);
                    }
                    else {
                        patches = [];
                        pInss.set(list1[len1 - ed], patches);
                    }
                    patches.push(list2[i]);
                }
                else {
                    pTailsIn.push(list2[i]);
                }
            }
            else if (shouldMoved) {
                if (j < 0 || LIS[j] !== IT[k]) {
                    pMovs.push({
                        to: LIS[j] === undefined
                            ? sd === 0
                                ? undefined
                                : list1[sd - 1]
                            : list1[LIS[j]],
                        item: list1[IT[k] - 1]
                    });
                }
                else {
                    j--;
                }
            }
            last = IT[k] === -1 ? last : k;
        }
        return {
            type: ACTION_REORDER,
            payload: {
                removes: pRmvs,
                moves: pMovs,
                insertions: pInss,
                tailsInss: pTailsIn
            }
        };
    }
}

const normalizeVirtualNode = function (node) {
    let prevSibling = null;
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (child instanceof VirtualNode) {
            if (prevSibling) {
                prevSibling.nextSibling = child;
            }
            prevSibling = child;
            continue;
        }
        const normalizedNode = new VirtualNode();
        if (prevSibling) {
            prevSibling.nextSibling = normalizedNode;
        }
        prevSibling = normalizedNode;
        if (isArray(child)) {
            normalizedNode.tagType = NODE_TYPE_LIST;
            normalizedNode.children = child;
            normalizeVirtualNode(normalizedNode);
            for (const subChild of normalizedNode.children) {
                subChild.parentNode = normalizedNode;
            }
        }
        else if (isString(child) || isNumber(child)) {
            normalizedNode.tagType = NODE_TYPE_TEXT;
            normalizedNode.value = child;
        }
        else if (isNil(child)) {
            normalizedNode.tagType = NODE_TYPE_EMPTY;
            normalizedNode.value = child;
        }
        else if (isFunction(child)) {
            normalizedNode.tagType = child;
        }
        node.children[i] = normalizedNode;
    }
};
class VirtualNode {
    constructor() { }
    static createElement(tagType, attrs, ...children) {
        const vNode = new VirtualNode();
        vNode.tagType = tagType;
        attrs = attrs || {};
        vNode.attributes = {};
        vNode.events = {};
        vNode.children = (children || []);
        if (vNode.isFragmentNode()) {
            attrs = {};
        }
        Object.entries(attrs).forEach(([key, value]) => {
            if (key === PROP_CLASS_PRESERVED || key === PROP_CHILDREN) ;
            else if (key === PROP_STYLE) {
                if (isPlainObject(value)) {
                    vNode.attributes[PROP_STYLE] = value;
                }
            }
            else if (key === PROP_KEY) {
                vNode[PROP_KEY] = value;
            }
            else if (key === PROP_DANGEROUS_HTML) {
                if (isString(value) || isFunction(value)) {
                    vNode.attributes[PROP_DANGEROUS_HTML] = value;
                }
            }
            else {
                if (key === PROP_REF) {
                    vNode.ref = value;
                }
                if (isString(value)) {
                    vNode.attributes[key] = value;
                }
                else if (isArray(value)) {
                    if (vNode.isComponentNode() ||
                        (vNode.isTaggedDomNode() && key === PROP_CLASS)) {
                        vNode.attributes[key] = value;
                    }
                }
                else if (isPlainObject(value)) {
                    if (vNode.isComponentNode()) {
                        vNode.attributes[key] = value;
                    }
                }
                else if (isFunction(value)) {
                    if (vNode.isTaggedDomNode() &&
                        key.slice(0, 2) === PROP_EVENT_PREFIX) {
                        vNode.events[key] = value;
                    }
                    else {
                        vNode.attributes[key] = value;
                    }
                }
            }
        });
        normalizeVirtualNode(vNode);
        if (vNode.isComponentNode()) {
            vNode.attributes.children = VirtualNode.createElement(NODE_TYPE_FRAGMENT, null, ...vNode.children);
            vNode.children = [];
        }
        for (const child of vNode.children) {
            if (isPlainObject(child)) {
                child.parentNode = vNode;
            }
        }
        return vNode;
    }
    static createEmptyNode() {
        const node = new VirtualNode();
        node.el = null;
        node.tagType = NODE_TYPE_EMPTY;
        return node;
    }
    findAncestor(conditionFunc) {
        let ancestor = this.parentNode;
        while (ancestor && !conditionFunc(ancestor)) {
            ancestor = ancestor.parentNode;
        }
        return ancestor;
    }
    isEmptyNode() {
        return this.tagType === NODE_TYPE_EMPTY;
    }
    isTextNode() {
        return this.tagType === NODE_TYPE_TEXT;
    }
    isListNode() {
        return this.tagType === NODE_TYPE_LIST;
    }
    isFragmentNode() {
        return this.tagType === NODE_TYPE_FRAGMENT;
    }
    isComponentNode() {
        return isFunction(this.tagType);
    }
    isTaggedDomNode() {
        return (!this.isEmptyNode() &&
            !this.isComponentNode() &&
            !this.isTextNode() &&
            !this.isListNode() &&
            !this.isFragmentNode());
    }
    sameTypeWith(that) {
        if (!this.isTaggedDomNode() && !that.isTaggedDomNode()) {
            return this.tagType === that.tagType;
        }
        return true;
    }
    getDomParentNode() {
        let ancestor = this.parentNode;
        while (ancestor && !ancestor.isTaggedDomNode()) {
            ancestor = ancestor.parentNode;
        }
        return ancestor.el;
    }
    getParentCompNode() {
        let ancestor = this.parentNode;
        while (ancestor && !ancestor.isComponentNode()) {
            ancestor = ancestor.parentNode;
        }
        return ancestor.el;
    }
    getDomChildrenVNodes() {
        if (this.isTaggedDomNode() || this.isTextNode()) {
            return [this];
        }
        else if (this.isEmptyNode()) {
            return [];
        }
        const vNodes = [];
        dfsWalk(this, PROP_CHILDREN, (child) => {
            if (child.isTaggedDomNode() || child.isTextNode()) {
                vNodes.push(child);
                return false;
            }
            return true;
        });
        return vNodes;
    }
    getChildrenCompNodes() {
        const comps = [];
        dfsWalk(this, PROP_CHILDREN, (child) => {
            if (child.isComponentNode()) {
                comps.push(child.el);
                return false;
            }
            return true;
        });
        return comps;
    }
    getMostLeftDomNodeInSubTree() {
        const { children } = this;
        if (!isArray(children) || !children.length) {
            return null;
        }
        for (const child of children) {
            if (child.isComponentNode() || child.isFragmentNode()) {
                return child.getMostLeftDomNodeInSubTree();
            }
            else if (child.isTaggedDomNode() || child.isTextNode()) {
                return child;
            }
            else {
                return null;
            }
        }
    }
    /**
     * TODO: fix the bug described below.
     * ! if 'the most left dom node' does not found in the next sibling, it may exists in next
     * ! sibling of next sibling, etc., here the method just look upon the ancestor nodes until the
     * ! most-left-dom found or no more ancestors.
     */
    getNextDomSibling() {
        let targetNode = null;
        let currentNode = this;
        do {
            const { nextSibling } = currentNode;
            if (nextSibling) {
                if (nextSibling.isTaggedDomNode() || nextSibling.isTextNode()) {
                    targetNode = nextSibling;
                    break;
                }
                targetNode = nextSibling.getMostLeftDomNodeInSubTree();
                if (targetNode) {
                    break;
                }
            }
            currentNode = currentNode.parentNode;
        } while (!currentNode.isTaggedDomNode());
        return targetNode && targetNode.el;
    }
    setDiffable(diffable) {
        this.diffable = diffable;
    }
    hasPatchable() {
        return !isNil(this.patchable);
    }
    setPatchable(patchable) {
        this.patchable = patchable;
    }
    clearPatchable() {
        delete this.patchable;
    }
    reconcile(that) {
        this.diffable.run(this, that);
    }
    reflectToDom() {
        let el = null;
        const { tagType, attributes, events } = this;
        if (this.isComponentNode()) {
            const compRender = tagType;
            const appContext = this.getParentCompNode().getAppContext();
            const TargetComponent = appContext.getComponent(compRender);
            el = new TargetComponent(appContext, this);
            el.forceRenderDom();
            return this;
        }
        else if (this.isTextNode()) {
            el = document.createTextNode(this.value);
        }
        else if (this.isEmptyNode()) {
            return this;
        }
        else if (this.isTaggedDomNode()) {
            el = document.createElement(this.tagType);
            if (isPlainObject(this.ref)) {
                this.ref.current = el;
            }
            for (const key in attributes) {
                if (attributes.hasOwnProperty(key)) {
                    const value = attributes[key];
                    if (key === PROP_CLASS) {
                        if (isString(value)) {
                            el.className = value;
                        }
                        else if (isArray(value)) {
                            value.forEach((cls) => {
                                if (isString(cls)) {
                                    el.classList.add(cls);
                                }
                            });
                        }
                    }
                    else if (key === PROP_STYLE) {
                        loadStyle(el, value);
                    }
                    else if (key === PROP_DANGEROUS_HTML) {
                        // children nodes will be disactive due to the dangerous inner html
                        this.children = [];
                        loadDangerousInnerHTML(el, value);
                    }
                    else {
                        el.setAttribute(key, value);
                    }
                }
            }
            for (const key in events) {
                if (events.hasOwnProperty(key)) {
                    const eventHandler = events[key];
                    if (isFunction(eventHandler)) {
                        el[key.toLowerCase()] = eventHandler;
                    }
                }
            }
        }
        this.el = el;
        this.mountToDom();
        return this;
    }
    reflectDescendantsToDom() {
        dfsWalk(this, PROP_CHILDREN, (offspring) => {
            offspring.reflectToDom();
            return !offspring.isComponentNode();
        });
    }
    mountToDom() {
        if (this.isTaggedDomNode() || this.isTextNode()) {
            const nextDomSibling = this.getNextDomSibling();
            if (nextDomSibling) {
                this.getDomParentNode().insertBefore(this.el, nextDomSibling);
            }
            else {
                this.getDomParentNode().appendChild(this.el);
            }
        }
    }
    unmountFromDom() {
        if (this.isTaggedDomNode() || this.isTextNode()) {
            this.getDomParentNode().removeChild(this.el);
        }
        else if (this.isComponentNode() || this.isFragmentNode()) {
            const domChildrenVNodes = this.getDomChildrenVNodes();
            for (const vNode of domChildrenVNodes) {
                vNode.el.parentNode.removeChild(vNode.el);
            }
        }
    }
    commit() {
        dfsWalk(this, PROP_CHILDREN, (node) => {
            if (isNil(node.patchable)) {
                return true;
            }
            node.patchable.run();
            return true;
        });
    }
}
__decorate([
    DiffAlgorithmFactory(DiffAlgorithmLisBased)
], VirtualNode.prototype, "diffable", void 0);

class Component {
    static memo(funcComp) {
        funcComp.clazz = class PureComponent extends Component {
            constructor(context, virtualNode) {
                super(context, virtualNode);
            }
            shouldComponentUpdate(prevProps) {
                const { virtualNode: { attributes: curProps } } = this;
                if (!prevProps) {
                    return true;
                }
                for (const key in curProps) {
                    if (key === PROP_CHILDREN) {
                        continue;
                    }
                    if (curProps.hasOwnProperty(key)) {
                        if (!prevProps.hasOwnProperty(key) ||
                            !Object.is(curProps[key], prevProps[key])) {
                            return true;
                        }
                    }
                }
                return false;
            }
        };
        return funcComp;
    }
    constructor(appContext, virtualNode) {
        this.appContext = appContext;
        this.stateHooks = [];
        this.contextCompMap = new WeakMap();
        this.currEffectHooks = [];
        this.currEffectRelativeStates = [];
        this.effectCleanups = [];
        this.initialized = false;
        this.waitingContextProviderUpdate = false;
        this.virtualNode = virtualNode;
        this.virtualNode.children[0] = VirtualNode.createEmptyNode();
        this.virtualNode.children[0].parentNode = this.virtualNode;
        this.virtualNode.el = this;
    }
    isInitialized() {
        return this.initialized;
    }
    shouldComponentUpdate(prevProps) {
        return true;
    }
    activateWaitingContextProviderUpdate() {
        this.waitingContextProviderUpdate = true;
    }
    disactivateWaitingContextProviderUpdate() {
        this.waitingContextProviderUpdate = false;
    }
    isWaitingContextProviderUpdate() {
        return this.waitingContextProviderUpdate;
    }
    getContextCompMap() {
        return this.contextCompMap;
    }
    /**
     * force render dom, without checking property mutations
     */
    forceRenderDom() {
        this.renderDom(null);
    }
    renderDom(prevProps) {
        this.appContext.batchingUpdate(() => {
            if (!this.shouldComponentUpdate(prevProps) ||
                this.appContext.hasDirtyComponent(this)) {
                return;
            }
            StaticContext.setCurrentInstance(this);
            // push current component into dirty components
            this.appContext.pushDirtyStateComponent(this);
            this.prevEffectHooks = this.currEffectHooks;
            this.currEffectHooks = [];
            this.prevEffectRelativeStates = this.currEffectRelativeStates;
            this.currEffectRelativeStates = [];
            this.stateHookIndex = 0;
            const newVirtualDom = this.render(this.virtualNode.attributes);
            // if effect hooks exists, call them after dom updated
            if (this.currEffectHooks.length !== 0) {
                this.appContext.pushDirtyEffectComponent(this);
            }
            // mount sub virtual dom tree to global virtual dom tree
            newVirtualDom.parentNode = this.virtualNode;
            this.virtualNode.children[0].reconcile(newVirtualDom);
            StaticContext.clearCurrentInstance();
            this.initialized = true;
        }, this);
    }
    reflectToDom() {
        if (!isNil(this.virtualNode)) {
            this.virtualNode.children[0].commit();
        }
    }
    useStateHook(state) {
        let stateValue = state;
        const { stateHooks, stateHookIndex, initialized } = this;
        if (initialized) {
            stateValue = stateHooks[stateHookIndex];
        }
        else {
            stateHooks.push(state);
        }
        this.stateHookIndex++;
        return [
            stateValue,
            (newState) => {
                this.appContext.batchingUpdate(() => {
                    if (isNil(this.virtualNode)) {
                        return;
                    }
                    stateHooks[stateHookIndex] = newState;
                    this.forceRenderDom();
                }, this);
            }
        ];
    }
    useEffect(effect, relativeState) {
        const { prevEffectHooks, currEffectHooks, prevEffectRelativeStates, currEffectRelativeStates } = this;
        if (!isEqualArray(prevEffectRelativeStates[currEffectRelativeStates.length], relativeState)) {
            currEffectHooks.push(effect);
            currEffectRelativeStates.push(relativeState);
        }
        else {
            currEffectHooks.push(prevEffectHooks[currEffectHooks.length]);
            currEffectRelativeStates.push(prevEffectRelativeStates[currEffectRelativeStates.length]);
        }
    }
    callEffectHooks() {
        for (let i = 0; i < this.currEffectHooks.length; i++) {
            const prevState = this.prevEffectRelativeStates[i];
            const currState = this.currEffectRelativeStates[i];
            const effect = this.currEffectHooks[i];
            const prevCleanup = this.effectCleanups[i];
            if (!isEqualArray(prevState, currState) || !this.initialized) {
                if (isFunction(prevCleanup)) {
                    prevCleanup.call(this);
                }
                this.effectCleanups[i] = effect.call(this);
            }
        }
    }
    callEffectCleanups() {
        for (let i = 0; i < this.effectCleanups.length; i++) {
            const callback = this.effectCleanups[i];
            if (isFunction(callback)) {
                callback.call(this);
            }
        }
    }
    unmount() {
        dfsWalk(this.virtualNode, PROP_CHILDREN, (node) => {
            if (node.el &&
                node.el instanceof Component &&
                node !== this.virtualNode) {
                node.el.unmount();
                // children virtual dom tree should be unmounted in the component
                // where it being used, dfs-walk break if current node is component
                return false;
            }
            return true;
        });
        this.callEffectCleanups();
        this.virtualNode = null;
        if (isFunction(this.afterUnmount)) {
            this.afterUnmount();
        }
    }
    getAppContext() {
        return this.appContext;
    }
}

const componentFac = function (render) {
    const ParentComponentDeclaration = render.clazz || Component;
    class RenderRelayComponent extends ParentComponentDeclaration {
        constructor(context, virtualNode) {
            super(context, virtualNode);
        }
    }
    latentSet(RenderRelayComponent.prototype, 'render', render);
    return RenderRelayComponent;
};

class AppContext {
    constructor() {
        this.componentDeclarationMap = new WeakMap();
        this.performing = false;
        this.wrappers = [
            AppContext.BATCHING_UPDATE_STRATEGY,
            AppContext.BATCH_INVOKE_EFFECTS_STRATEGY
        ];
        this.dirtyStateComponentStack = [];
        this.dirtyStateComponentMap = new WeakMap();
        this.dirtyEffectComponentStack = [];
        this.dirtyEffectComponentMap = new WeakMap();
    }
    getComponent(render) {
        if (this.componentDeclarationMap.has(render)) {
            return this.componentDeclarationMap.get(render);
        }
        else {
            const TargetComponent = componentFac(render);
            this.componentDeclarationMap.set(render, TargetComponent);
            return TargetComponent;
        }
    }
    perform(callback, scope, ...args) {
        this.performing = true;
        this.beforeAll();
        callback.apply(scope, args);
        this.afterAll();
        this.performing = false;
    }
    beforeAll() {
        for (const wrapper of this.wrappers) {
            wrapper.before.call(this);
        }
    }
    afterAll() {
        for (const wrapper of this.wrappers) {
            wrapper.after.call(this);
        }
    }
    batchingUpdate(callback, scope, ...args) {
        const { performing } = this;
        this.performing = true;
        if (performing) {
            return callback.apply(scope, args);
        }
        else {
            this.perform(callback, scope, args);
        }
    }
    pushDirtyStateComponent(comp) {
        if (!this.dirtyStateComponentMap.has(comp)) {
            this.dirtyStateComponentStack.push(comp);
            this.dirtyStateComponentMap.set(comp, true);
        }
    }
    hasDirtyComponent(comp) {
        return this.dirtyEffectComponentMap.get(comp);
    }
    pushDirtyEffectComponent(comp) {
        if (!this.dirtyEffectComponentMap.has(comp)) {
            this.dirtyEffectComponentStack.push(comp);
            this.dirtyEffectComponentMap.set(comp, true);
        }
    }
}
AppContext.BATCHING_UPDATE_STRATEGY = {
    before() { },
    after() {
        // batching update state
        let comp = this.dirtyStateComponentStack.pop();
        while (comp) {
            comp.reflectToDom();
            comp = this.dirtyStateComponentStack.pop();
        }
        this.dirtyStateComponentMap = new WeakMap();
    }
};
AppContext.BATCH_INVOKE_EFFECTS_STRATEGY = {
    before() { },
    after() {
        // batching invoke effect
        let comp = this.dirtyEffectComponentStack.pop();
        while (comp) {
            comp.callEffectHooks();
            comp = this.dirtyEffectComponentStack.pop();
        }
        this.dirtyEffectComponentMap = new WeakMap();
    }
};

class Context {
    static createContext(initialValue) {
        class Provider extends Component {
            constructor(context, virtualNode) {
                super(context, virtualNode);
                this.decendantConsumers = new Set();
            }
            getValue() {
                const { attributes: { value } } = this.virtualNode;
                return isNil(value) ? initialValue : value;
            }
            subscribe(consumer) {
                const { decendantConsumers } = this;
                decendantConsumers.add(consumer);
                return () => {
                    decendantConsumers.delete(consumer);
                };
            }
            renderDom(prevProps) {
                this.appContext.batchingUpdate(() => {
                    const { attributes: { value } } = this.virtualNode;
                    const shouldUpdate = this.isInitialized() &&
                        (!prevProps || !Object.is(prevProps.value, value));
                    if (shouldUpdate) {
                        for (const decendantConsumer of this.decendantConsumers) {
                            decendantConsumer.activateWaitingContextProviderUpdate();
                        }
                    }
                    super.renderDom(prevProps);
                    if (shouldUpdate) {
                        for (const decendantConsumer of this.decendantConsumers) {
                            decendantConsumer.forceRenderDom();
                            decendantConsumer.disactivateWaitingContextProviderUpdate();
                        }
                    }
                }, this);
            }
        }
        class Consumer extends Component {
            constructor(context, virtualNode) {
                super(context, virtualNode);
                const ancestorNode = this.virtualNode.findAncestor((node) => node.el instanceof Provider);
                this.ancestorProvider = ancestorNode
                    ? ancestorNode.el
                    : null;
                this.unsubscriber = ancestorNode
                    ? this.ancestorProvider.subscribe(this)
                    : null;
            }
            unmount() {
                super.unmount();
                if (this.unsubscriber) {
                    this.unsubscriber();
                }
            }
        }
        const providerRender = function () {
            return this.virtualNode.attributes.children;
        };
        providerRender.clazz = Provider;
        const consumerRender = function () {
            const fac = this.virtualNode.attributes.children
                .children[0].tagType;
            return fac(this.ancestorProvider ? this.ancestorProvider.getValue() : initialValue);
        };
        consumerRender.clazz = Consumer;
        const contextComp = {
            initialValue,
            Provider: providerRender,
            Consumer: consumerRender
        };
        return contextComp;
    }
    static useContextComposer(...args) {
        if (args.length === 0) {
            return null;
        }
        const InitContext = args.pop();
        return ({ children, values }) => args.reduceRight((Acc, Context, index) => VirtualNode.createElement(Context.Provider, {}, Acc), VirtualNode.createElement(InitContext.Provider, { value: values[args.length] }, ...children));
    }
}

class Riact extends AppContext {
    constructor(virtualNode, rootDom) {
        super();
        warning(!isNil(virtualNode), 'empty virtual dom');
        warning(rootDom instanceof HTMLElement, 'invalid root dom element');
        this.appContext = this;
        this.virtualNode = virtualNode;
        // the mounted dom pointer is a virtual node as well
        const rootNode = new VirtualNode();
        rootNode.tagType = rootDom.tagName;
        rootNode.el = rootDom;
        // basicly the class Riact is a special function component, the root
        // component, which always return same virtual dom in render
        this.virtualNode = new VirtualNode();
        rootNode.children = [this.virtualNode];
        this.virtualNode.tagType = () => this.virtualNode;
        this.virtualNode.el = this;
        this.virtualNode.parentNode = rootNode;
        // mount a empty component onto root component, it will be replaced in
        // the first reconciliation
        const emptyNode = VirtualNode.createEmptyNode();
        this.virtualNode.children = [emptyNode];
        emptyNode.parentNode = this.virtualNode;
        this.batchingUpdate(() => {
            this.pushDirtyStateComponent(this);
            emptyNode.reconcile(virtualNode);
        }, this);
    }
    static render(virtualNode, rootDom) {
        rootDom.innerHTML = '';
        return new Riact(virtualNode, rootDom);
    }
    reflectToDom() {
        this.virtualNode.children[0].commit();
    }
    callEffectHooks() { }
    render() {
        return this.virtualNode;
    }
    getAppContext() {
        return this;
    }
}
Riact.createContext = Context.createContext;
Riact.createElement = VirtualNode.createElement;
Riact.createRef = createRef;
Riact.memo = Component.memo;
Riact.useState = StaticContext.useState;
Riact.useEffect = StaticContext.useEffect;
Riact.useContext = StaticContext.useContext;
Riact.useContextComposer = Context.useContextComposer;
Riact.Fragment = NODE_TYPE_FRAGMENT;
const useState = StaticContext.useState;
const useEffect = StaticContext.useEffect;
const useContext = StaticContext.useContext;
const useContextComposer = Context.useContextComposer;

exports.default = Riact;
exports.useState = useState;
exports.useEffect = useEffect;
exports.useContext = useContext;
exports.useContextComposer = useContextComposer;
