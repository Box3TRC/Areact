"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flushHookEffects = exports.endHooks = exports.startHooks = exports.useRef = exports.useInlineEffect = exports.useEffect = exports.useCallback = exports.useMemo = exports.useLocal = exports.useState = exports.createHookInstance = void 0;
const aluminaGlobal_1 = require("./aluminaGlobal");
function createHookInstance() {
    return {
        holders: [],
        index: 0,
        pendingEffectHolders: [],
    };
}
exports.createHookInstance = createHookInstance;
function hasDepsChanged(oldDeps, newDeps) {
    if (!oldDeps || !newDeps) {
        return true;
    }
    for (let i = 0; i < oldDeps.length; i++) {
        if (oldDeps[i] !== newDeps[i]) {
            return true;
        }
    }
    return false;
}
function getHookHolder() {
    const gHookInstance = aluminaGlobal_1.aluminaGlobal.gHookInstance;
    if (!gHookInstance) {
        throw new Error('hook functions called outside render context');
    }
    const hk = gHookInstance;
    let holder = hk.holders[hk.index];
    let first = false;
    if (!holder) {
        holder = hk.holders[hk.index] = {};
        first = true;
    }
    hk.index++;
    return { holder, first };
}
function useState(initialValue) {
    const { holder, first } = getHookHolder();
    if (first) {
        holder.value = initialValue;
        holder.setValue = (arg) => {
            if (typeof arg === 'function') {
                holder.value = arg(holder.value);
            }
            else {
                holder.value = arg;
            }
        };
    }
    const { value, setValue } = holder;
    return [value, setValue];
}
exports.useState = useState;
function useLocal(arg) {
    const initialValue = 'call' in arg ? arg() : arg;
    const [value] = useState(initialValue);
    return value;
}
exports.useLocal = useLocal;
function useMemo(func, deps) {
    const { holder } = getHookHolder();
    const changed = hasDepsChanged(holder.deps, deps);
    if (changed) {
        holder.value = func();
        holder.deps = deps;
    }
    return holder.value;
}
exports.useMemo = useMemo;
function useCallback(func, deps) {
    const { holder } = getHookHolder();
    const changed = hasDepsChanged(holder.deps, deps);
    if (changed) {
        holder.value = func;
        holder.deps = deps;
    }
    return holder.value;
}
exports.useCallback = useCallback;
function useEffect(effectFunc, deps) {
    const { holder } = getHookHolder();
    const changed = hasDepsChanged(holder.deps, deps);
    if (changed) {
        holder.effectFunc = effectFunc;
        holder.deps = deps;
        const gHookInstance = aluminaGlobal_1.aluminaGlobal.gHookInstance;
        gHookInstance.pendingEffectHolders.push(holder);
    }
}
exports.useEffect = useEffect;
function useInlineEffect(effectFunc, deps) {
    const { holder } = getHookHolder();
    const changed = hasDepsChanged(holder.deps, deps);
    if (changed) {
        const result = effectFunc();
        if (result && typeof result === 'function') {
            holder.cleanupFunc = result;
        }
        holder.deps = deps;
    }
}
exports.useInlineEffect = useInlineEffect;
function useRef() {
    const { holder, first } = getHookHolder();
    if (first) {
        holder.refObject = { current: undefined };
    }
    return holder.refObject;
}
exports.useRef = useRef;
function startHooks(target) {
    target.index = 0;
    aluminaGlobal_1.aluminaGlobal.gHookInstance = target;
}
exports.startHooks = startHooks;
function endHooks() {
    aluminaGlobal_1.aluminaGlobal.gHookInstance = undefined;
}
exports.endHooks = endHooks;
function flushHookEffects(target, all = false) {
    const holders = (all ? target.holders : target.pendingEffectHolders);
    holders.forEach((holder) => {
        if (holder.cleanupFunc) {
            holder.cleanupFunc();
            holder.cleanupFunc = undefined;
        }
        if (holder.effectFunc) {
            const result = holder.effectFunc();
            if (result && typeof result === 'function') {
                holder.cleanupFunc = result;
            }
            aluminaGlobal_1.aluminaGlobal.asyncRerenderFlag = true;
            holder.effectFunc = undefined;
        }
    });
    target.pendingEffectHolders = [];
}
exports.flushHookEffects = flushHookEffects;
//# sourceMappingURL=hookImpl.js.map