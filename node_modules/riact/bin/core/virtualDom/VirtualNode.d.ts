import Component from '../component/Component';
import Diffable from './Diffable';
import Patchable from './Patchable';
declare class VirtualNode implements JSX.Element {
    static createElement(tagType: string | Riact.TFuncComponent, attrs: any, ...children: Array<JSX.Element>): JSX.Element;
    static createEmptyNode(): VirtualNode;
    tagType: string | Riact.TFuncComponent;
    attributes?: Riact.TObject;
    children?: Array<VirtualNode>;
    el?: Node | Riact.IComponent;
    events?: Riact.TFuncValObject;
    key?: string;
    nextSibling?: VirtualNode;
    parentNode?: VirtualNode;
    ref?: Riact.TRef;
    reserved?: any;
    value?: any;
    private diffable;
    private patchable?;
    constructor();
    findAncestor(conditionFunc: Riact.TFunction): VirtualNode;
    isEmptyNode(): boolean;
    isTextNode(): boolean;
    isListNode(): boolean;
    isFragmentNode(): boolean;
    isComponentNode(): boolean;
    isTaggedDomNode(): boolean;
    sameTypeWith(that: VirtualNode): boolean;
    getDomParentNode(): Node;
    getParentCompNode(): Component;
    getDomChildrenVNodes(): Array<VirtualNode>;
    getChildrenCompNodes(): Array<Component>;
    getMostLeftDomNodeInSubTree(): VirtualNode;
    /**
     * TODO: fix the bug described below.
     * ! if 'the most left dom node' does not found in the next sibling, it may exists in next
     * ! sibling of next sibling, etc., here the method just look upon the ancestor nodes until the
     * ! most-left-dom found or no more ancestors.
     */
    getNextDomSibling(): Node;
    setDiffable(diffable: Diffable): void;
    hasPatchable(): boolean;
    setPatchable(patchable: Patchable): void;
    clearPatchable(): void;
    reconcile(that: VirtualNode): void;
    reflectToDom(): VirtualNode;
    reflectDescendantsToDom(): void;
    mountToDom(): void;
    unmountFromDom(): void;
    commit(): void;
}
export default VirtualNode;
